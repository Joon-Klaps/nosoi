---
title: "Get started"
author: "Sebastian Lequime"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getstarted}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Setting up the core functions

`nosoi` runs under a series of user defined probabilities and numbers ( [see General principles](nosoi.html#essential-building-blocs-3-probabilities-and-2-numbers) ). Each follows the same principles to be set up. We will detail here how to set up a correct function to be used into the simulator; this will apply for the functions `pExit`, `pMove`, `moveDist`, `timeContact` and `pTrans`.

## Expected output

Every function which name starts with a `p` (i.e. `pExit`, `pMove` and `pTrans`) should give back a single probability (a number between 0 and 1). 

`timeContact` should give back a positive natural number (positive integer), while `moveDist` can give whatever number back.

## Function arguments

A core function used by `nosoi` should be at least expressed as a function of `t` (e.g. `pExit(t)`), even if `t` is not used within the body of the function. 
Thus, to have a constant value to be returned, the function should be expressed as:

```{r pFunction1, eval = FALSE}
p_Function  <- function(t){0.08}
```

This will give back a single value (0.08). 
If this probability/number should dependent on time since initial infection of the host, then you only have to add `t` in the body of the function, such as in the following example:

```{r pFunction2, eval = FALSE}
p_Function  <- function(t){plogis(t,10,2)}
```

Here the probability/number will follow a logistic distribution with parameters $\mu$ 10 and $s$ 2.
If you want your probability/number to be dependant on the "absolute" time of the simulation (not to be confused with the time since infection `t`, which is individual-dependant), then you have to add the argument `prestime` (for "present time"), such as:

```{r pFunction3, eval = FALSE}
p_Function  <- function(t,prestime){(sin(prestime/12)+1)/2}
```

In that specific case, the function will give back values following a periodic pattern.
If you want your probability/number to be dependant on the location where the host is present (only if you use a structured population), then you have to add the argument `current.in` (discrete structure) or `current.env.value` (continuous structure).

```{r pFunction4, eval = FALSE}
p_Function  <- function(t,current.in){
  if(current.in=="A"){return(0)}
  if(current.in=="B"){return(0.5)}
  if(current.in=="C"){return(1)}} #discrete (between states "A","B" and "C")

p_Function  <- function(t,current.env.value){current.env.value/100} #continuous
```

For more details on how to set up the influence of the structure, please refer to the tutorials: [discrete](single-host-discrete.html) or [continuous](single-host-continuous.html) structure.

## Parameters

If you want one of the parameters of the logistic distribution (or any other function) to be individual host-dependant (including some heterogeneity between hosts), then you can add a parameter:

```{r pFunction5, eval = FALSE}
p_Function  <- function(t,pFunction.param1){plogis(t,pExit.param1,2)}
```

In this case, the $\mu$ parameter will be determined for each individual host by another function that you have to specify. Here we will use:

```{r pFunction6, eval = FALSE}
p_Function_param1 <- function(x){rnorm(x,mean = 10,sd=2)} #sampling one parameter for each infected individual
```

\mu will be sample from a normal distribution (mean 10 and sd 2). Notice here that the function is expressed as a function of `x` instead of `t`. `x` is present in the body of the function as the number of draws to make in the distribution. Every parameter function you specify should be compiled into a list, where the function determining the parameter for each individual (right) can be named (left), using the name provided in p_Function for this parameter.

```{r pFunction7, eval = FALSE}
p_Function_parameters  <- list(pFunction.param1 = p_Function_param1)
```

## Combining arguments

We have previously seen that you can combine the time since infection `t` with other parameters such as `current.in` or `prestime`. In fact, you can combine as many arguments as you want, making a function dependant of time since ifnection, current location, presentime and individual host-dependant parameters. They however need to respect a specific order to be correctly parsed by the simulator: first `t`, then `prestime`, then `current.in` (discrete) or `current.env.value` (continuous) and finally individual host-dependant parameters.

```{r pFunction8, eval = FALSE}
p_Function  <- function(t, prestime, current.in, pFunction.param1, pFunction.param2,...){}
```
